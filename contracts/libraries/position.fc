#include "./common.fc";
#include "../imports/stdlib.fc";
#include "./full_math.fc";
#include "./liquidity_math.fc";

const int error::position::NP = 0x2000;

(int, int, int, int, int) position::info(slice data) {
    int liquidity = data~load_uint(128);
    int fee_growth_inside_0_last_x128 = data~load_uint(256);
    int fee_growth_inside_1_last_x128 = data~load_uint(128);
    int tokens_owed_0 = data~load_uint(128);
    int tokens_owed_1 = data~load_uint(128);
    return (
        liquidity, 
        fee_growth_inside_0_last_x128, 
        fee_growth_inside_1_last_x128, 
        tokens_owed_0, 
        tokens_owed_1
    );
}

(int, int, int, int, int) position::get(cell self, slice owner, int tick_lower, int tick_upper) {
    slice key = begin_cell()
        .store_slice(owner)
        .store_int(tick_lower, 24)
        .store_int(tick_upper, 24)
        .end_cell()
        .begin_parse();
    int key = string_hash(key);
    (slice data, int existed) = self.idict_get?(256, key);
    return position::info(data);
}

(cell, ()) position::_update(slice self, int liquidity_delta, int fee_growth_inside_0_x128, int fee_growth_inside_1_x128) {
    (
        int liquidity, 
        int fee_growth_inside_0_last_x128, 
        int fee_growth_inside_1_last_x128, 
        int tokens_owed_0, 
        int tokens_owed_1
    ) = position::info(self);

    int liquidity_next = 0;
    if (liquidity_delta == 0) {
        throw_unless(error::position::NP, liquidity > 0);
        liquidity_next = liquidity;
    } else {
        liquidity_next = liquidity_math::add_delta(liquidity, liquidity_delta);
    }

    int tokens_owed_0 = full_math::mul_div(fee_growth_inside_0_x128 - fee_growth_inside_0_last_x128, liquidity, fixed_point_128::q128);
    int tokens_owed_1 = full_math::mul_div(fee_growth_inside_1_x128 - fee_growth_inside_1_last_x128, liquidity, fixed_point_128::q128);

    if (liquidity_delta != 0) {
        liquidity = liquidity_next;
    }
    fee_growth_inside_0_last_x128 = fee_growth_inside_0_x128;
    fee_growth_inside_1_last_x128 = fee_growth_inside_1_x128;
    if ((tokens_owed_0 > 0) | (tokens_owed_1 > 0)) {
        tokens_owed_0 += tokens_owed_0;
        tokens_owed_1 += tokens_owed_1;
    }

    return (begin_cell()
        .store_uint(liquidity, 128)
        .store_uint(fee_growth_inside_0_last_x128, 256)
        .store_uint(fee_growth_inside_1_last_x128, 128)
        .store_uint(tokens_owed_0, 128)
        .store_uint(tokens_owed_1, 128)
        .end_cell(), ());
}

(cell, ()) position::update(
    cell self, 
    slice owner, 
    int tick_lower, 
    int tick_upper, 
    int liquidity_delta, 
    int fee_growth_inside_0_x128, 
    int fee_growth_inside_1_x128
) {
    slice key = begin_cell()
        .store_slice(owner)
        .store_int(tick_lower, 24)
        .store_int(tick_upper, 24)
        .end_cell()
        .begin_parse();
    int key = string_hash(key);
    (slice data, int existed) = self.idict_get?(256, key);
    (cell data, _)= position::_update(data, 
        liquidity_delta, 
        fee_growth_inside_0_x128, 
        fee_growth_inside_1_x128
    );
    self~idict_set(256, key, data.begin_parse());
    return (self, ());
}