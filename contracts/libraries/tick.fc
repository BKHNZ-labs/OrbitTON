#include "./tick_math.fc";
#include "./common.fc";
#include "./liquidity_math.fc";

const int error::tick::L0 = 0x3000;

;;tick#_ liquidity_gross:uint128 liquidity_net:int128 fee_growth_outside_0_x128:uint256 
;;fee_growth_outside_1_x128:uint256 tick_cumulative_outside:int56 initialized:Bool = Info;
(int, int, int, int, int, int) unpack_tick(cell tick){
    slice tick_cs = tick.begin_parse();
    (int liquidity_gross, 
        int liquidity_net, 
        int fee_growth_outside_0_x128, 
        int fee_growth_outside_1_x128, 
        int tick_cumulative_outside, 
        int initialized) = (tick_cs~load_uint(128), tick_cs~load_int(128), tick_cs~load_uint(256), tick_cs~load_uint(256), tick_cs~load_int(56), tick_cs~load_int(1));
    return (liquidity_gross, 
        liquidity_net, 
        fee_growth_outside_0_x128, 
        fee_growth_outside_1_x128, 
        tick_cumulative_outside, 
        initialized);
}

builder pack_tick(
    int liquidity_gross, 
    int liquidity_net, 
    int fee_growth_outside_0_x128, 
    int fee_growth_outside_1_x128, 
    int tick_cumulative_outside, 
    int initialized
) {
    return begin_cell()
                .store_uint(128, liquidity_gross)
                .store_int(128, liquidity_net)
                .store_uint(256, fee_growth_outside_0_x128)
                .store_uint(256, fee_growth_outside_1_x128)
                .store_int(56, tick_cumulative_outside)
                .store_int(1, initialized);

}
               

int tick::tick_spacing_to_max_liquidity_per_tick(int tick_spacing){
    int min_tick = (tick_math::MIN_TICK / tick_spacing) * tick_spacing;
    int min_tick = (tick_math::MIN_TICK / tick_spacing) * tick_spacing;
    int num_ticks = ((max_tick - min_tick) / tick_spacing) + 1;
    return max::uint128 / num_ticks;

}

(int, int) tick::get_fee_growth_inside(
    cell tick_map,
    int tick_lower,
    int tick_upper,
    int tick_current,
    int fee_growth_global_0X128,
    int fee_growth_global_1X128 
) {
    cell lower = tick_map.idict_get?(24, tick_lower);
    cell upper = tick_map.idict_get?(24, tick_upper);
    (
        int lower_liquidity_gross, 
        int lower_liquidity_net, 
        int lower_fee_growth_outside_0_x128, 
        int lower_fee_growth_outside_1_x128, 
        int lower_tick_cumulative_outside, 
        int lower_initialized
    ) = lower.unpack_tick();
    (
        int upper_liquidity_gross, 
        int upper_liquidity_net, 
        int upper_fee_growth_outside_0_x128, 
        int upper_fee_growth_outside_1_x128, 
        int upper_tick_cumulative_outside, 
        int upper_initialized
    ) = upper.unpack_tick();
    int fee_growth_below_0_x128 = 0;
    int fee_growth_below_1_x128 = 0;
    if (tick_current >= tick_lower) {
        fee_growth_below_0_x128 = lower_fee_growth_outside_0_x128;
        fee_growth_below_1_x128 = lower_fee_growth_outside_1_x128;
    } else {
        fee_growth_below_0_x128 = fee_growth_global_0X128 - lower_fee_growth_outside_0_x128;
        fee_growth_below_1_x128 = fee_growth_global_1X128 - lower_fee_growth_outside_1_x128;
    }

    int fee_growth_above_0_x128 = 0;
    int fee_growth_above_1_x128 = 0;

    if(tick_current < tick_upper){
        fee_growth_above_0_x128 = upper_fee_growth_outside_0_x128;
        fee_growth_above_1_x128 = upper_fee_growth_outside_1_x128;
    } else {
        fee_growth_above_0_x128 = fee_growth_global_0X128 - upper_fee_growth_outside_0_x128;
        fee_growth_above_1_x128 = fee_growth_global_1X128 - upper_fee_growth_outside_1_x128;
    }
    return (fee_growth_global_0X128 - fee_growth_below_0_x128 - fee_growth_above_0_x128, fee_growth_global_1X128 - fee_growth_below_1_x128 - fee_growth_above_1_x128);
}

(cell, (int)) ~tick::update(
    cell tick_map,
    int tick,
    int tick_current,
    int liquidity_delta,
    int fee_growth_global_0_x128,
    int fee_growth_global_1_x128,
    int seconds_per_liquidity_cumulative_x128,
    int tick_cumulative,
    int time,
    int upper,
    int max_liquidity
) {
    cell info_raw = tick_map.idict_get?(24, tick);

    (
        int liquidity_gross_before, 
        int liquidity_net, 
        int fee_growth_outside_0_x128, 
        int fee_growth_outside_1_x128, 
        int tick_cumulative_outside, 
        int initialized
    ) = info_raw.unpack_tick();

    int liquidity_gross_after = liquidity_math::add_delta(liquidity_gross_before, liquidity_delta);

    throw_unless(error::tick::L0, liquidity_gross_after <= max_liquidity);

    int flipped = (liquidity_gross_after == 0) & (liquidity_gross_before == 0);

    if (liquidity_gross_before == 0){
        if(tick <= tick_current){
            fee_growth_outside_0_x128 = fee_growth_global_0_x128;
            fee_growth_outside_1_x128 = fee_growth_global_1_x128;
            tick_cumulative_outside = tick_cumulative;
        }
        initialized = -1;
    }
    liquidity_net = upper ? liquidity_net - liquidity_delta : liquidity_net + liquidity_delta;

    cell new_tick = pack_tick(liquidity_gross_after, liquidity_net, fee_growth_outside_0_x128, fee_growth_outside_1_x128, tick_cumulative_outside, initialized);
    
    tick_map~idict_set_builder(24, tick, new_tick);
    
    return flipped;
}

(cell, ()) ~tick::clear(
    cell tick_map,
    int tick
) {
    tick_map ~idict_delete?(24,tick);
}

(cell, (int)) ~tick::cross(
    cell tick_map,
    int tick,
    int fee_growth_global_0_x128,
    int fee_growth_global_1_x128,
    int seconds_per_liquidity_cumulative_x128,
    int tick_cumulative,
    int time
){
    cell info_raw = tick_map.idict_get?(24, tick);
    (
        int liquidity_gross, 
        int liquidity_net, 
        int fee_growth_outside_0_x128, 
        int fee_growth_outside_1_x128, 
        int tick_cumulative_outside, 
        int initialized
    ) = info_raw.unpack_tick();

    fee_growth_outside_0_x128 = fee_growth_global_0_x128 - fee_growth_outside_0_x128;
    fee_growth_outside_1_x128 = fee_growth_global_1_x128 - fee_growth_outside_1_x128;
    tick_cumulative_outside = tick_cumulative - tick_cumulative_outside;
    tick_map~idict_set_builder(24,tick,pack_tick(liquidity_gross,liquidity_net,fee_growth_outside_0_x128,fee_growth_outside_1_x128,tick_cumulative_outside,initialized));
    return liquidity_net;
}