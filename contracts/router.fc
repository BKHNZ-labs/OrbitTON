#include "imports/stdlib.fc";
#include "common/utils.fc";
#include "common/messages.fc";
#include "common/address.fc";
#include "common/errors.fc";
#include "common/op_codes.fc";
#include "router/storage.fc";
#include "router/opcodes.fc";
#include "router/utils.fc";
#include "pool/opcodes.fc";

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore all empty messages        
    return ();
  }

  slice cs = in_msg_full.begin_parse();
   
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  load_data(); ;; here we populate the storage variables

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
  int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

  if (op == op::jetton_transfer_notification()) {
    (int jetton_amount, slice from_user) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());
    cell ref_cs = in_msg_body~load_ref();
    slice ref_ds = ref_cs.begin_parse();
    throw_unless(error:not_enough_amount, jetton_amount > 0);
    (int forward_opcode, slice jetton1_wallet) = (in_msg_body~load_uint(32), in_msg_body~load_msg_addr());
    if (forward_opcode == op::mint) {
      int sqrt_price_x96 = ref_ds~load_int(160);
      int tick_lower = ref_ds~load_int(24);
      int tick_upper = ref_ds~load_int(24);
      int fee = ref_ds~load_uint(24);
      int tick_spacing = ref_ds~load_int(24);
      int liquidity_delta = ref_ds~load_int(128);
      slice jetton0_wallet = sender_address;
      (cell state_init, slice pool_address) = get_pool_state_init_and_address(sqrt_price_x96, jetton0_wallet, jetton1_wallet, fee);
      builder msg_body = begin_cell()
                    .store_uint(op::mint, 32)
                    .store_uint(query_id, 64);
      if (slice_hash(jetton0_wallet) < slice_hash(jetton1_wallet)) {
        msg_body = msg_body.store_coins(jetton_amount);
        msg_body = msg_body.store_coins(0);
      } else {
        msg_body = msg_body.store_coins(0);
        msg_body = msg_body.store_coins(jetton_amount);
      }
      msg_body = msg_body                    
                  .store_int(tick_lower, 24)
                  .store_int(tick_upper, 24)
                  .store_int(tick_spacing, 24)
                  .store_ref(begin_cell()
                              .store_slice(pool_address)
                              .store_slice(from_user)
                              .end_cell());
      send_message_with_stateinit(0, pool_address, state_init, msg_body.end_cell(), CARRY_REMAINING_GAS);
    }

    if (forward_opcode == op::swap) {

    }

    if (forward_opcode == op::burn) {

    }
    return ();  
  }

  if (op == op::pay_to) {
    slice recipient = in_msg_body~load_msg_addr();
    int exit_code = in_msg_body~load_uint(32);
    slice ds = in_msg_body~load_ref().begin_parse();
    int sqrt_price_x96 = ds~load_int(160);
    slice token0_address = ds~load_msg_addr();
    int token0_amount = ds~load_coins();
    slice token1_address = ds~load_msg_addr();
    int token1_amount = ds~load_coins();
    int fee = ds~load_uint(24);
    (cell state_init, slice pool_address) = get_pool_state_init_and_address(sqrt_price_x96, token0_address, token1_address, fee);
    throw_unless(error::unauthorized, compare_address(sender_address, pool_address) != -1);
    if (token0_amount > 0) {
      var body0 = create_simple_transfer_body(query_id, 0, token0_amount, recipient);
      body0 = body0.store_uint(exit_code, 32); ;; append exit code
      send_simple_message(0, token0_address, body0.end_cell(), CARRY_REMAINING_GAS);
    }
    if (token1_amount > 0) {
      var body1 = create_simple_transfer_body(query_id, 0, token1_amount, recipient);
      body1 = body1.store_uint(exit_code, 32); ;; append exit code
      send_simple_message(0, token1_address, body1.end_cell(), CARRY_REMAINING_GAS);
    }
    return ();
  }

  ;; [MONITOR]
  if (op == op::set_admin_address) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    slice new_address = in_msg_body~load_msg_addr();
    storage::admin_address = new_address;
    save_data();
    return ();
  }

  if (op == op::update_lock_state) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    storage::is_locked = in_msg_body~load_int(8);
    save_data();
    return ();
  }

  if (op == op::update_pool_code) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    storage::pool_code = in_msg_body~load_ref();
    save_data();
    return ();
  }

  if (op == op::update_batch_tick_code) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    storage::batch_tick_code = in_msg_body~load_ref();
    save_data();
    return ();
  }

  if (op == op::update_position_code) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    storage::position_code = in_msg_body~load_ref();
    save_data();
    return ();
  }

  if (op == op::update_lp_account_code) {
    throw_if(error::unauthorized, compare_address(sender_address, storage::admin_address) != -1);
    storage::lp_account_code = in_msg_body~load_ref();
    save_data();
    return ();
  }

  throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

slice get_admin_address() method_id {
  ~dump(null());
  load_data();
  return storage::admin_address;
}

int get_is_locked() method_id {
  load_data();
  return storage::is_locked;
}

cell get_pool_code() method_id {
  load_data();
  return storage::pool_code;
}

cell get_batch_tick_code() method_id {
  load_data();
  return storage::batch_tick_code;
}

cell get_position_code() method_id {
  load_data();
  return storage::position_code;
}

cell get_lp_account_code() method_id {
  load_data();
  return storage::lp_account_code;
}

