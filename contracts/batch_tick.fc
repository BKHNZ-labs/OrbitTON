#include "imports/stdlib.fc";
#include "common/utils.fc";
#include "common/messages.fc";
#include "common/address.fc";
#include "common/errors.fc";
#include "batch_tick/constants.fc";
#include "batch_tick/errors.fc";
#include "batch_tick/opcodes.fc";
#include "batch_tick/storage.fc";
#include "batch_tick/utils.fc";
#include "libraries/tick.fc";
#include "pool/opcodes.fc";

;; (int, slice, int) find_next_tick(int tick_index, int zero_for_one) {
;;   if (zero_for_one) {
;;     return ticks.dict_get_prev?(key_len, tick_index);
;;   }
;;   return ticks.dict_get_next?(key_len, tick_index);
;; }

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore all empty messages        
    return ();
  }

  slice cs = in_msg_full.begin_parse();
   
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  load_data(); ;; here we populate the storage variables

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
  int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

  if (op == op::update_tick_lower) {
    throw_unless(error::unauthorized, compare_address(sender_address, storage::pool_address));
    int tick_lower = in_msg_body~load_int(24);
    int tick_upper = in_msg_body~load_int(24);
    int lower_range = storage::batch_index * storage::tick_spacing * constants::batch_index_range;
    int upper_range = (storage::batch_index + 1) * storage::tick_spacing * constants::batch_index_range - 1;
    throw_unless(error::wrong_range_batch_tick, (tick_lower <= tick_upper) & (tick_lower >= lower_range) & (tick_lower <= upper_range));
    int current_tick = in_msg_body~load_int(24);
    int liquidity_delta = in_msg_body~load_uint(128);
    int fee_growth_global_0X128 = in_msg_body~load_uint(256);
    int fee_growth_global_1X128 = in_msg_body~load_uint(256);
    int upper = in_msg_body~load_int(2);
    throw_unless(error::wrong_upper, upper == 0);
    int max_liquidity = in_msg_body~load_uint(128);
    slice recipient = in_msg_body~load_ref().begin_parse();
    int flipped_lower = storage::ticks~tick::update(tick_lower, current_tick, liquidity_delta, fee_growth_global_0X128, fee_growth_global_1X128, upper, max_liquidity);
    (int fee_growth_below_0X128, int fee_growth_below_1X128) = storage::ticks.tick::get_fee_growth_below(tick_lower, current_tick,  fee_growth_global_0X128,
      fee_growth_global_1X128);
    if (tick_upper > upper_range) {
      int upper_batch_tick_index = calculate_batch_tick_index(tick_upper, storage::tick_spacing);
      (cell state_init, slice upper_batch_tick_address) = get_batch_tick_state_init_and_address(upper_batch_tick_index, storage::tick_spacing, storage::pool_address, storage::batch_tick_code);
      builder msg = begin_cell()
                      .store_uint(op::update_tick_upper, 32)
                      .store_uint(query_id, 64)
                      .store_int(flipped_lower, 2)
                      .store_int(tick_lower, 24)
                      .store_int(tick_upper, 24)
                      .store_int(current_tick, 24)
                      .store_uint(liquidity_delta, 128)
                      .store_uint(fee_growth_global_0X128, 256)
                      .store_uint(fee_growth_global_1X128, 256)
                      .store_int(-1, 2) ;; true
                      .store_uint(max_liquidity, 128)
                      .store_ref(begin_cell()
                            .store_uint(fee_growth_below_0X128, 256)
                            .store_uint(fee_growth_below_1X128, 256)
                            .store_slice(recipient)
                          .end_cell()
      );
      send_message_with_stateinit(0, upper_batch_tick_address, state_init, msg.end_cell(), CARRY_REMAINING_GAS);
    } else {
      int flipped_upper = storage::ticks~tick::update(tick_upper, current_tick, liquidity_delta, fee_growth_global_0X128, fee_growth_global_1X128, upper, max_liquidity);
      (int fee_growth_above_0X128, int fee_growth_above_1X128) = storage::ticks.tick::get_fee_growth_above(
        tick_upper,
        current_tick,
        fee_growth_global_0X128,
        fee_growth_global_1X128 
      );
        (int fee_growth_inside_0X128, int fee_growth_inside_1X128) = tick::get_fee_growth_inside(
        fee_growth_global_0X128,
        fee_growth_global_1X128,
        fee_growth_below_0X128,
        fee_growth_below_1X128,
        fee_growth_above_0X128,
        fee_growth_above_1X128
      );
      builder msg = begin_cell()
                    .store_uint(op::cb_update_fee_growth_inside, 32)
                    .store_uint(query_id, 64)
                    .store_ref(
                      begin_cell()
                          .store_int(storage::batch_index, 16)
                          .store_uint(liquidity_delta, 128)
                          .store_int(tick_lower, 24)
                          .store_int(flipped_lower, 2)
                          .store_int(tick_upper, 24)
                          .store_int(flipped_upper, 2)
                          .store_uint(fee_growth_inside_0X128, 256)
                          .store_uint(fee_growth_inside_1X128, 256)
                          .store_slice(recipient)
                        .end_cell()
                    );
      send_simple_message(0, storage::pool_address, msg.end_cell(), CARRY_REMAINING_GAS);
      if (liquidity_delta < 0 & flipped_upper) {
        storage::ticks~idict_delete?(24, tick_upper);
      }
    }
    if (liquidity_delta < 0 & flipped_lower) {
      storage::ticks~idict_delete?(24, tick_lower);
    }
    save_data();
    return ();
  }

  if (op == op::update_tick_upper) {
    int prev_batch_tick_index = storage::batch_index - 1;
    slice prev_batch_tick_address = get_batch_tick_address(prev_batch_tick_index, storage::tick_spacing, storage::pool_address, storage::batch_tick_code);
    throw_unless(error::unauthorized, compare_address(sender_address, prev_batch_tick_address));
    int flipped_lower = in_msg_body~load_int(2);
    int tick_lower = in_msg_body~load_int(24);
    int tick_upper = in_msg_body~load_int(24);
    int tick = in_msg_body~load_int(24);
    int lower_range = storage::batch_index * storage::tick_spacing * constants::batch_index_range;
    int upper_range = (storage::batch_index + 1) * storage::tick_spacing * constants::batch_index_range - 1;
    throw_unless(error::wrong_range_batch_tick, (tick_upper >= lower_range) & (tick_upper <= upper_range));
    int liquidity_delta = in_msg_body~load_uint(128);
    int fee_growth_global_0X128 = in_msg_body~load_uint(256);
    int fee_growth_global_1X128 = in_msg_body~load_uint(256);
    int upper = in_msg_body~load_int(2);
    throw_unless(error::wrong_upper, upper == -1);
    int max_liquidity = in_msg_body~load_uint(128);
    slice fee_lower_info_cs = in_msg_body~load_ref().begin_parse();
    (int fee_growth_below_0X128, int fee_growth_below_1X128) = (fee_lower_info_cs~load_uint(256), fee_lower_info_cs~load_uint(256));
    slice recipient = fee_lower_info_cs~load_msg_addr();
    (int fee_growth_above_0X128, int fee_growth_above_1X128) = storage::ticks.tick::get_fee_growth_above(
      tick_upper,
      tick,
      fee_growth_global_0X128,
      fee_growth_global_1X128 
    );
    (int fee_growth_inside_0X128, int fee_growth_inside_1X128) = tick::get_fee_growth_inside(
      fee_growth_global_0X128,
      fee_growth_global_1X128,
      fee_growth_below_0X128,
      fee_growth_below_1X128,
      fee_growth_above_0X128,
      fee_growth_above_1X128
    );
    int flipped_upper = storage::ticks~tick::update(tick_upper, tick, liquidity_delta, fee_growth_global_0X128, fee_growth_global_1X128, upper, max_liquidity);
    builder msg = begin_cell()
                    .store_uint(op::cb_update_fee_growth_inside, 32)
                    .store_uint(query_id, 64)
                    .store_ref(
                      begin_cell()
                          .store_int(storage::batch_index, 16)
                          .store_uint(liquidity_delta, 128)
                          .store_int(tick_lower, 24)
                          .store_int(flipped_lower, 2)
                          .store_int(tick_upper, 24)
                          .store_int(flipped_upper, 2)
                          .store_uint(fee_growth_inside_0X128, 256)
                          .store_uint(fee_growth_inside_1X128, 256)
                          .store_slice(recipient)
                        .end_cell()
                    );
    send_simple_message(0, storage::pool_address, msg.end_cell(), CARRY_REMAINING_GAS);
    if (liquidity_delta < 0 & flipped_upper) {
      storage::ticks~idict_delete?(24, tick_upper);
    }
    save_data();
    return ();
  }

  if (op == op::internal_swap) {
    ;; throw_unless(error::unauthorized, compare_address(sender_address, storage::pool_address));
    ;; (int amount_specified, int sqrt_price_x96, int zero_for_one, int sqrt_price_limit_x96, int tick, int fee_growth_global_x128, int protocol_fee) = (
    ;;   in_msg_body~load_int(128),
    ;;   in_msg_body~load_uint(160),
    ;;   in_msg_body~load_int(2),
    ;;   in_msg_body~load_uint(160),
    ;;   in_msg_body~load_int(24),
    ;;   in_msg_body~load_uint(256),
    ;;   in_msg_body~load_uint(128)
    ;; );
    ;; slice next_ref = in_msg_body~load_ref().begin_parse();
    ;; slice response_address = next_ref~load_msg_addr();
    
    ;; while ((amount_specified != 0) & (sqrt_price_x96 != sqrt_price_limit_x96)) {
    ;;   int step::sqrt_price_start_x96 = sqrt_price_x96;
    ;;   (int prev, slice tick, int existed) = find_next_tick(tick, zero_for_one);
    ;; }
    return ();
  }

  if (op == op::cross_swap) {
    
  }

  throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}

slice get_tick(
    int tick
) method_id {
    load_data();
    (slice tick, int exist) = storage::ticks.idict_get?(24,tick);
    if (exist){
        return tick;
    } 
    return begin_cell()
            .store_int(0, 128)
            .store_int(0, 128)
            .store_uint(0, 256)
            .store_uint(0, 256)
            .store_int(0, 1)
            .end_cell().begin_parse();
}